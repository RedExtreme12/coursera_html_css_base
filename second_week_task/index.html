<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Yandex Blog</title>
</head>
<body>
  <header>
    <h1>Блог компании Яндекс.</h1> <!-- Header of site. -->
  </header>

  <artilce>
    <header>
      <h1>ЯНДЕКС.ПОЧТА: КАК МЫ ИЗМЕРЯЕМ СКОРОСТЬ ЗАГРУЗКИ И УЛУЧШАЕМ ЕЁ</h1>
    </header>

    <p>
      Если ваш сайт медленно грузится, вы рискуете тем, что люди не оценят ни то,<br>
      какой он красивый, ни то, какой он удобный. Никому не понравится, когда все<br>
      тормозит. Мы регулярно добавляем в Яндекс.Почту новую функциональность,<br>
      иногда — исправляем ошибки, а это значит, у нас постоянно появляются новый код<br>
      и новая логика. Всё это напрямую влияет на скорость работы интерфейса.
    </p>

    <section>
      <article>
        <header>
          <h2>Что мы измеряем</h2>
        </header>

        <p>Этапы первой загрузки:</p>
        <ul>
          <li>подготовка;</li>  
          <li>загрузка статики (HTTP-запрос и парсинг);</li>
          <li>исполнение модулей;</li>
          <li>инициализация базовых объектов;</li>
          <li>отрисовка.</li>
        </ul>

        <p>Этапы отрисовки любой страницы:</p>
        <ul>
          <li>подготовка к запросу на сервер;</li>
          <li>запрос данных с сервера;</li>
          <li>шаблонизация;</li>
          <li>обновление DOM.</li>
        </ul>

        <p>
          — <q>Ок, теперь у нас есть метрики, мы можем отправить их на сервер</q> - <cite>говорим мы</cite><br>
          — <q>Что же дальше?</q> - <cite>вопрошаете вы</cite><br>
          — <q>А давай построим график!</q> - <cite>отвечаем мы</cite><br>
          — <q>А что будем считать?</q> - <cite>уточняете вы</cite><br>
        </p>  

        <p>
          Как вы знаете, медиана – это серединное, а не среднее значение в выборке.<br>
          Если у нас имеются числа 1, 2, 2, 3, 8, 10, 20, то медиана – 3, а среднее – 6,5.<br>
          В общем случае медиана отлично показывает, сколько грузится средний пользователь.
        </p>

        <p>
          В случае ускорения или замедления медиана, конечно, изменится. Но она не может<br>
          рассказать, сколько пользователей ускорилось, а сколько замедлилось.
        </p>

        <p>
          APDEX – метрика, которая сразу говорит: хорошо или плохо. Метрика<br>
          работает очень просто. Мы выбираем временной интервал [0; t], такой, что если<br>
          время показа страницы попало в него, то пользователь счастлив. Берем еще один<br>
          интервал, (t; 4t] (в четыре раза больше первого), и считаем, что если страница<br>
          показана за это время, то пользователь в целом удовлетворен скоростью работы,<br>
          но уже не настолько счастлив. И применяем формулу:<br>
          <p>
            (кол-во счастливых пользователей + кол-во удовлетворенных / 2) / (кол-во всех). <br>
            Получается значение от нуля до единицы, которое, видимо, лучше всего показывает, <br>
            хорошо или плохо работает почта.
          </p>
        </p>



      </article>

      <article>
        <header>
          <h2>Как мы измеряем</h2>
        </header>

        <p>
          Сейчас модуль обновления сам логирует все свои стадии, и можно легко понять<br>
          причину замедления: медленнее стал отвечать сервер либо слишком долго<br>
          выполняется JavaScript. Выглядит это примерно так:
        </p>

        <code>
          this.timings['look-ma-im-start'] = Date.now();<br>
          this.timings['look-ma-finish'] = Date.now();
        </code>

        <p>
          C помощью <code>Date.now()</code> мы получаем текущее время. Все тайминги собираются и при<br>
          отправке рассчитываются. На этапах разница между “end” и “start” не считается,<br>
          а все вычисления производятся в конце:
        </p>

        <code>var totalTime = this.timings['look-ma-finish'] - this.timings['look-ma-im-start'];</code>

        <p>И на сервер прилетают подобные записи:</p>

        <code>serverResponse=50&domUpdate=60</code>
      </article>

      <article>
        <header>
          <h2>Как мы ускоряем</h2>
        </header>

        <p>Чтобы снизить время загрузки почты при выходе новых версий,<br>
          мы уже делаем следующее:</p>
        <ul>
          <li>включаем gzip;</li>
          <li>выставляем заголовки кэширования;</li>
          <li>фризим CSS, JS, шаблоны и картинки;</li>
          <li>используем CDN;</li>
        </ul>

        <p>
          Мы подумали: «А что если хранить где-то старую версию файлов, а при выходе новой<br>
          передавать только diff между ней и той, которая сохранена у пользователя?»<br>
          В браузере же останется просто наложить патч на клиенте.</br>
        </p>

        <p>
          На самое деле эта идея не нова. Уже существуют стандарты для HTTP — например,<br>
          RFC 3229 «Delta encoding in HTTP» и «Google SDHC», — но по разным причинам они<br>
          не получили должного распространения в браузерах и на серверах.
        </p>

        <p>
          Мы же решили сделать свой аналог на JS. Чтобы реализовать этот метод обновления,<br>
          начали искать реализации diff на JS. На популярных хостингах кода нашли<br>
          библиотеки:
          <div>
            - VCDiff<br>
            - google-diff-patch-match
          </div>
        </p>

        <p>Для окончательного выбора библиотеки нам нужно сравнить:</p>
        <table>
          <tr> <!-- first row. -->
            <td>Библиотека</td>
            <td>|</td>
            <td>IE 9</td>
            <td>|</td>
            <td>Opera 12</td>
          </tr>
          <tr> <!-- second row. -->
            <td></td>
            <td></td>
            <td></td>
          </tr>
          <tr> <!-- third row. -->
            <td></td>
            <td></td>
            <td></td>
          </tr>
          <tr> <!-- fourth row. -->
            <td></td>
            <td></td>
            <td></td>
          </tr>
        </table>

      </article>
    </section>

    <footer>

    </footer>
  </artilce>


</body>
</html>